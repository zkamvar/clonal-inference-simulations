---
title: "ROC Analysis"
author: "Zhian N. Kamvar"
date: "October 16, 2016"
output: html_document
---

## Introduction

I've created 10,000 simulations of populations undergoing different levels of
sexual reproduction and analyzed the index of association along with genotypic
and allelic diversity metrics, including an analysis of the contribution of each
locus to the genotypic diversity. 

This document will perform a power analysis of $\bar{r}_d$ by calculating
Receiver Operator Characteristic (ROC) Curves. These curves are useful in
assessing the power of an analysis by assessing the true positive fraction and
false positive fraction against different values of $\alpha$. 

In our case, we are asking the question:

> How well can $\bar{r}_d$ detect non-random mating (clonal reproduction)?


## Analysis

### Overall ROC Curve

We will be looking at factors such as sample size, percent of clonal 
reproduction, and variable mutation rates. To perform the analyis, the data will
be split up into two sets: "Random Mating" and "Non-Random Mating". The Random 
mating set will always be the data set where the sex rate is one. This will
serve to assess our Type 1 (False Positive) fraction. The Non-Random mating
component will each rate of sexual reproduction less than one. In this data set,
that means that 9 total ROC curves will be produced for each overall comparison.

### ROC Curve by Seed

Since we simulated the populations in a way such that each parent population is
one of 10 replicates spawned from 100 unique seeds across rates of sexual
reproduction, we can group the populations by seed and calculate an ROC Curve
for each seed.

### Area Under the ROC Curve (AURC)

The Area under the ROC Curve will be calcuated via the `auc()` function via
*flux*. 

## Setup

```{r, required_packages}
library('zksimanalysis')
```

This here will load in all of the results of the analyses. These were previously
processed in the file `ssr_data_cleaning.Rmd`. The name of the data was called
"vals".

```{r, load_data, cache = TRUE, results = "hide", cache.lazy = FALSE}
system.time({
res        <- load("../../simulation_results/processed_results.rda")
vals_by_cc <- vals %>% 
  gather(clone_correction, pval, p.rD, p.rDcc) %>%
  mutate(clone_correction = ifelse(clone_correction == "p.rD", "wd", "cc"))
})
vals_by_cc
```

## Data Analysis

### Overall ROC Calculation

```{r, generate_sexrate}
sex <- unique(vals$sexrate)
sex <- sex[!sex %in% "1.0000"]
alpha <- seq(0, 1, by = 0.01)
```

The main ROC calculation is handled by the function `roc()`. This function
calculates ROC and the variance for a single level of $\alpha$ over a given
grouping. It assumes the column for the factor dividing the true positive and
false positive is called "sexrate". This will calculate ROC and the variance
for each level of the grouping (which must be at least sexrate). 

Since we want create a curve, here we are mapping the `roc()` function over the 
different levels of $\alpha$. We do this for both the regular p-value and clone 
corrected p-value. We then do this for each rate of sexual reproduction 
independently. To do this, we have to use nested `map()` functions. The first 
`map_df()` will map the second map function over the values of non-random
mating, `map2_df()`, which will map the `roc()` function over both the incoming
value of non-random mating (coming in as `.x`) and all values of $\alpha$
(represented as `.y`).

We do this for both full and clone-corrected data.

```{r, roc_overall, cache = TRUE}
Sys.time()
total_roc <- map_df(alpha, roc, 
                    vals_by_cc %>% mutate(sexrate = ifelse(sexrate == "1.0000", "R", "NR")),
                    compare = c("NR", "R"), stat = "pval", count.na = TRUE,
                    group = c("mutation_rate", "sexrate", "sample", "clone_correction"))
total_roc

Sys.time()
roc_overall <- sex %>% 
  map_df(.f = map2_df, alpha, 
         ~roc(.y, vals_by_cc, compare = c(.x, "1.0000"), count.na = TRUE, 
              group = c("mutation_rate", "sexrate", "sample", "clone_correction"), 
              stat = "pval"
             )
         ) 
roc_overall
Sys.time()
```


```{r, curves, fig.width = 10, fig.height = 10}
old_theme <- theme_set(theme_bw())
old_theme <- theme_update(axis.text.x = element_text(angle = 90, vjust = 0.5))

oroc_plot <- ggplot(roc_overall, aes(x = `False Positive`, y = `True Positive`)) +
  geom_line(aes(color = sample)) +
  facet_grid(sexrate ~ mutation_rate + clone_correction) +
  geom_abline(slope = 1, lty = 3) +
  labs(list(
    # title = "ROC Curves",
    # subtitle = "over mutation rate and clone-correction by sex rate",
    pch = "Sample Size",
    color = "Sample Size"
  )) +
  theme(aspect.ratio = 1) +
  theme(legend.position = "top") +
  theme(panel.grid.minor = element_blank()) +
  theme(text = element_text(size = 14)) +
  scale_color_brewer(palette = "Set1")
oroc_plot
total_oroc_plot <- ggplot(total_roc, aes(x = `False Positive`, y = `True Positive`)) +
  geom_line(aes(color = sample)) +
  facet_grid(mutation_rate ~ clone_correction) +
  geom_abline(slope = 1, lty = 3) +
  labs(list(
    title = "ROC Curves",
    pch = "Sample Size",
    color = "Sample Size"
  )) +
  theme(aspect.ratio = 1) +
  theme(legend.position = "top") +
  theme(text = element_text(size = 14)) +
  scale_color_brewer(palette = "Set1")
total_oroc_plot
```

```{r, roc_by_seed, cache = TRUE}
seedgroup <- c("mutation_rate", "sexrate", "run", "seed", "sample", "clone_correction")
Sys.time()
roc_by_seed <- sex %>% 
  map_df(.f = map2_df, alpha, 
         ~roc(.y, vals_by_cc, compare = c(.x, "1.0000"), count.na = TRUE, 
              group = seedgroup, stat = "pval"
             )
         ) 
roc_by_seed
Sys.time()
```

### AURC

Here we calculate the Area Under the ROC Curve using the function `auc()` from
the package *flux*.

```{r, AURC_calc, cache = TRUE}
# Calculate ROC over all seeds, produce points

AURC_calc <- . %>%
  summarize(AURC = auc(`False Positive`, `True Positive`)) %>%
  ungroup() %>% 
  mutate(sample = factor(paste("n =", sample), paste("n =", c(10, 25, 50, 100))))

Sys.time()
AURC_overall <- roc_overall %>% 
  group_by(sexrate, sample, mutation_rate, clone_correction) %>%
  AURC_calc

Sys.time()
# Calculate ROC for each seed separately, produce distributions
AURC_by_seed <- roc_by_seed %>% 
  group_by(run, seed, sexrate, sample, mutation_rate, clone_correction) %>%
  AURC_calc

```

Now we can visualize the data as facetted boxplots

```{r, AURC_plot, fig.width = 10, fig.height = 10}

# Add an annotation indicating that 0.5 is random assignment.
text_annotation <- data.frame(x = 0, y = 0.5, text = "0.5 = random", 
                              sample = "n = 10", mutation_rate = "even")

ggplot(AURC_by_seed, aes(x = factor(sexrate), y = AURC)) +
  geom_boxplot(aes(fill = clone_correction)) +
  annotate("rect", xmin = 0, xmax = 9.75, ymin = 0, ymax = 0.5, alpha = .2) +
  geom_boxplot(aes(fill = clone_correction)) +
  facet_grid(sample~mutation_rate) +
  geom_text(aes(x = x, y = y, label = text), hjust = -0.1, vjust = 1.5, color = "gray25",
            data = text_annotation) +
  geom_point(aes(x = factor(sexrate), y = AURC, pch = clone_correction), data = AURC_overall,
             position = position_dodge(width = 0.75), color = "black", fill = "white") +
  scale_shape_manual(values = c(21, 24)) + 
  labs(list(
    fill = "Clone Correction",
    pch = "Overall",
    x = "Rate of Sexual Reproduction",
    title = expression(paste("Area Under the ROC Curve for ", bar(r)[d])),
    subtitle = "calculated over sample size and mutation rate"
  )) +
  scale_fill_brewer(palette = "Set2") +
  theme(text = element_text(size = 14))


```


## Session Information

```{r session_info}
options(width = 100)
devtools::session_info()
```

